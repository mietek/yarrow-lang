-- File: LatexPr
-- Description: This module contains the latex pretty-printer for terms.
-- Generated by deleting all types, and all definitions not starting with "pr"
-- and replacing "pr" with "latexPr" (more or less)

-- CHANGE SINCE LAST VERSION: 
-- \qt{\laBxs}{X}{T}{A} instead of \lt{X}{T}{A}

-- Commands used
-- \sort<SORT>          e.g. \sortSts for *s
-- \var<SORT>           where SORT is the sort of the variable
-- \dtt
-- \qt{}{}{}{}          for any quantification
-- \at                  for application
-- \la<SORT>            for lambda-quantification
-- \pi<SORT>            for pi-quantification, <SORT> is the type of the body
-- \arrow<SORT>         for arrow, <SORT> is the type of the body
-- \yiv<INFIX SYMBOL>
-- \ylv<VAR>IIEEE{}{}{}{}{}      for variables declared with latexvar, an I for
--                               each implicit argument, an E for every
--                               explicit argument.
--                               The number given with latexvar indicates the
--                               maximum number of arguments the macro gets.
-- \ylv<VAR>IEEA{}{}{}{}{}       for variables declared with binder,
--                               for each 'A' there is one abstraction in the
--                               last argument: the variable and the type are
--                               given as argument to the latex macro.
-- For records:
-- \tot
-- \tct
-- \toT
-- \tcT
-- \mt
-- \mT
-- \recsep
-- \reclabel
-- \sel              
-- For subtyping:
-- qbkt{}{}{}{}{}        for any bounded quantification
-- For contexts
-- \begin{context}
-- \end{context}
-- \consub         "<"
-- \condecl        ":"
-- \condefterm     ":="
-- \condeftype     ":"
-- \condefab       "..."
-- \newcitem

-- So this printing routine makes it possible to distinguish different
-- sorts of Pi's and variables in the latex-document. In order to do so,
-- the printing routine needs to type-check terms. So it maintains the
-- context for the term to be printed.
-- There is a small problem here: we do not apply alpha-conversion here
-- (for esthetical reasons). This might cause the type-checking routine
-- to fail or to deliver a wrong answer.
-- In practice, this problem occurs rarely, so we ignore the problem.


-- How are infix variables with implicit arguments printed?
-- As example, take composition (&) with three implicit arguments.
-- It depends on the actual number of arguments:
--       args     | output for latex
--    ---------------------------
--        -       | \yivam
--     a          | \yivamI{a}
--     a,b        | \yivamII{a}{b}
--     a,b,c      | \yivamIII{a}{b}{c}
--     a,b,c,d    | \yivamIIIE{a}{b}{c}{d}
--     a,b,c,d,e  | \yivamIIIEE{a}{b}{c}{d}{e}
--     a,b,c,d,e,f| (\yivamIIIEE{a}{b}{c}{d}{e}) \at f
--
-- This is in the cases where implicit arguments are turned ON.
-- If this option is turned of, all 'I's are changed into 'E's.
--
-- Yarrow assumes that the LaTeX macro does not supplies parentheses.
--
-- ALTERNATIVE:
--   The disadvantage of the method above is some inflexibility, because of the
--   last assumption.
--   E.g. suppose we have
--               \yiveqI[1] == {=_{#1}},
--               \yivscI[1] == {(;) #1}
--   and consider for the terms
--    1)   IsTrans ((=) T)   
--    2)   rel := (=) T   
--    3)   IsTrans ((=) T) 
--    4)   rel := (=) T   
--   by the assumption above, we get in latex
--    1)   IsTrans (=_{T})   
--    2)   rel := (=_{T})
--    3)   IsTrans ((;) T) 
--    4)   rel := ((;) T) 
--   The brackets in case 4 are superfluous, but in 2 they are not.
--   To solve this, we need to make even more macros, one (appended with 'P')
--   that says: make sure there are brackets around the expression, and the
--   other macro (without 'P') that says there are no brackets necessary 
--   considering the context of the expression.

module LatexPr(-- polymorphic printing routines, e.g. of type
               -- DisplayTerm a -> .. -> a
               --DisplayTerm,
               latexPrintTermSt, sortToName, latexPrintVarSt,
               latexPrintVar, latexPrintTerm, latexPrintTermS, latexPrintTerm',
               --printSort, printVar,printTermS,
               --printContextE, 
               latexPrintContextSt,
               getSor, noErrDed
               ) where

-- This module defines printing routines for terms and
-- contexts as latex-input.
-- 


import HaTuple(space)
import HaMonSt(noErr)
import General
import Collect()
import Display

--import Basic
--import Paths
--import SyntaxI
import Engine
import Typing
import Errors(errorToStrings)

import Scanner

import Printer
      
{- for testing. Will only work under Gofer 
instance Text (Vari,Path) where
   showsPrec _ (v,path) = (v ++ concat (map show path))++                
-}
 

--------------------------
-- PRINTING EXPRESSIONS --
--------------------------
       
-- TERM  
latexPrintTerm :: SyntaxInfo -> Context -> Term -> String
latexPrintTerm si con term = 
       latexPrintTerm' si con term

latexPrintTerm' :: SyntaxInfo -> Context -> Term -> String
latexPrintTerm' si con abs | isAbs abs = 
        let (_,(v,t,s),u) = deconstructAbs abs
            con' = addC (mkDecl (v,t,s)) con  in
        latexPrintLambdaTerm si con' [v] t u
latexPrintTerm' si con all | isRealAll all =
        let (_,(v,t,s),u) = deconstructAll all
            con' = addC (mkDecl (v,t,s)) con  in
        latexPrintAllTerm si con' [v] t u
-- Extension: Subtyping:
latexPrintTerm' si con abs | isSubAbs abs =
        let (_,(v,b,t,s),u) = deconstructSubAbs abs
            con' = addC (mkSubDecl (v,b,t,s)) con
            (_,sortU) = getTypSor si con' u
            com = "\\qbkt{\\la" ++ sortToName sortU ++ "}" in
        latexPrintBinderOne si con' com v b t u
latexPrintTerm' si con all | isSubAll all =
        let (_,(v,b,t,s),u) = deconstructSubAll all
            con' = addC (mkSubDecl (v,b,t,s)) con
            sortU = getSor si con' u
            com = "\\qbkt{\\pi" ++ sortToName sortU ++ "}" in
        latexPrintBinderOne si con' com v b t u 
-- End Extension: Subtyping
latexPrintTerm' si con delta | isDelta delta =
        let (_,(v,d,t,s),u) = deconstructDelta delta
            con' = addC (mkDef (v,d,t,s)) con in 
        latexPrintBinderOne si con' "\\dtt" v d t u
latexPrintTerm' si con app | isApp app =
   let l = breakListL deconstructApp app
       h = head l
       (isVar,v) = deconstructVar h
       isBind = extractBind si v
       implicits = extractOptImplicit si
       numImp = if implicits then getImplicit si v else 0
       (impArgs,expArgs) = (take numImp (tail l), drop numImp (tail l)) in
   if isVar && isBind && length l >= 2 && isAbs (last l) then
      -- length l >= 2 makes sure there is at least one argument.
      -- otherwise, we handle this in the 'isLatex' case in latexPrintFactor
      -- print all arguments except the last in the ordinary way.
      -- We peel off all lambdas of the last argument
      let (vtss,u) = deconstructAbsMax (last l)
          con' = listToLocCon (map mkDecl vtss) `addLoc` con in
      "\\ylv" ++ v ++
      replicate (length impArgs) (if implicits then 'I' else 'E') ++ 
      replicate (length expArgs) 'E' ++ replicate (length vtss) 'A' ++
      concat (map (\t -> "{" ++ latexPrintTerm si con t ++ "}")
              (init (impArgs ++ expArgs))) ++ 
      concat (map (\(v,t,_) -> "{" ++ latexPrintVar si con' v ++ "}{" ++ 
                            latexPrintTerm si con' t ++ "}") (reverse vtss)) ++
      "{" ++ latexPrintTerm si con' u ++ "}" 
   else
      latexPrintSmall si con app
latexPrintTerm' si con t = latexPrintSmall si con t

latexPrintBinderOne si con com v b t u = 
        com ++ "{" ++ latexPrintVar si con v ++
        "}{" ++ latexPrintTerm si con b ++
        "}{" ++ latexPrintTerm si con t ++
        "}{" ++ latexPrintTerm si con u ++ "}"
       
latexPrintBinderTerm si con bv abs = 
    let (_,(v,t,s),u) = deconstructAbs abs
        con' = addC (mkDecl (v,t,s)) con in
    "\\qt{" ++ latexPrintVar si con bv ++ "}{" ++
    latexPrintVar si con' v ++ "}{" ++
    latexPrintTerm si con t ++ "}{" ++
    latexPrintTerm si con' u ++ "}"

-- abstractions with the same type are contracted
latexPrintLambdaTerm si con vl typ term =
        let (isAbs,(v,t,s),u) = deconstructAbs term in
        if isAbs && typ == t then
           let con' = addC (mkDecl (v,t,s)) con in
           latexPrintLambdaTerm si con' (vl++[v]) typ u
        else
           let (_,sortU) = getTypSor si con term in
           "\\qt{\\la" ++ sortToName sortU ++
           "}{" ++ latexPrintVarList si con vl ++
           "}{" ++ latexPrintTerm si con typ ++
           "}{" ++ latexPrintTerm si con term ++ "}"

-- same comment as for latexPrintLambdaTerm
latexPrintAllTerm si con vl typ term =
        let (isAll,(v,t,s),u) = deconstructAll term in
        if isAll && typ == t then
           let con' = addC (mkDecl (v,t,s)) con in
           latexPrintAllTerm si con'  (vl++[v]) typ u
        else
           let sortU = getSor si con term in
           "\\qt{\\pi" ++ sortToName sortU ++
           "}{" ++ latexPrintVarList si con vl ++
           "}{" ++ latexPrintTerm si con typ ++
           "}{" ++ latexPrintTerm si con term ++ "}"

getSor :: SyntaxInfo -> Context -> Term -> Sort
getSor si con t = noErrDed si (inferSort si con t)  

getTypSor :: SyntaxInfo -> Context -> Term -> (Term,Sort)
getTypSor si con t = noErrDed si (inferTypeSort si con t)  

noErrDed si = noErr (\mess -> "Latex/Ded Error: " ++ concat (errorToStrings si mess))

                           
-- 'SMALL' terms
latexPrintSmall si con t = 
     latexPrListConsSpaceR (latexPrintFactor si con 0 [])
                            mkSep 
                            (breakListR deconstructArrow t)
          where mkSep term = let sort = getSor si con term in
                             "\\arrow" ++ sortToName sort ++ " "

        
-- FACTOR
-- latexPrintFactor delivers a 'string',
-- It has argument a list of maybe one variable that should have no brackets
-- For the other cases, see latexPrListSpace below
latexPrintFactor :: SyntaxInfo -> Context -> Int -> 
                    [Vari] -> Term -> String
latexPrintFactor si con n noBrackList t = 
   let l = breakListL deconstructApp t
       h = head l
       (isVar,v) = deconstructVar h
       isOp = isVar && isOper v
       isBind = extractBind si v
       (isLatex,noLatex) = extractLatex si v
       numImp0 = getImplicit si v
       implicits = extractOptImplicit si in
   if isOp then 
      -- latexPrint INFIX !
      let (prec,as) = extractPrec si v
          numImp = numImp0 
          impArgs = take numImp (tail l)
          expArgs = drop numImp (tail l)
          infArgs = take 2 expArgs
          othArgs = drop 2 expArgs
          v' = latexPrintInfixVar si v ++ 
               replicate (length impArgs) (if implicits then 'I' else 'E') ++ 
               replicate (length infArgs) 'E' ++
               concat (map (\t -> "{" ++ latexPrintTerm si con t ++ "}")
                           impArgs)
          pArgs [] = v'
          pArgs [t1] = v' ++ "{" ++ latexPrintBasic2 si con t1 ++ "}"
          pArgs [t1,t2] = -- two arguments
              let printLower = latexPrintFactor si con (prec+1) []
                  printLEQ = latexPrintFactor si con (prec+1) [v] in
              case as of
              NoAssoc -> v' ++ "{" ++ printLower t1 ++ "}{" ++ 
                                      printLower t2 ++ "}"
              LeftAssoc -> v' ++ "{" ++ printLEQ t1 ++ "}{" ++ 
                                        printLower t2 ++ "}" 
              RightAssoc -> v' ++ "{" ++ printLower t1 ++ "}{" ++ 
                                         printLEQ t2 ++ "}"
          res = pArgs infArgs ++
                (if null othArgs then [] else 
                    "\\at" ++ latexPrListApp si con othArgs) in
      if (prec >= n || v `elem` noBrackList) && length expArgs == 2 then
         res
      else -- enclose in parentheses, see also latexPrintBasic last clause
           -- if something of the conditions above change.
         "(" ++ res ++ ")"
   else
   let numImp = if implicits then numImp0 else 0
       impArgs = take numImp (tail l)
       expArgs = drop numImp (tail l) in
   if isVar && isBind && length l >=2 && isAbs (last l) then
      latexPrintBasic2 si con t
   else if isVar && (isLatex || isBind) then
      let (impArgs',expArgs',restArgs) = 
             if isLatex then 
                (take noLatex impArgs,
                 take (noLatex-length impArgs) expArgs,
                 drop noLatex (impArgs++expArgs))
            else 
                (impArgs,expArgs,[]) in
      "\\ylv" ++ v ++ 
      replicate (length impArgs') (if implicits then 'I' else 'E') ++ 
      replicate (length expArgs') 'E' ++
      concat (map (\t -> "{" ++ latexPrintTerm si con t ++ "}")
              (impArgs' ++ expArgs')) ++ 
      latexPrListAppTail si con restArgs
   else
      let hargs = if isVar && implicits then dropImplic numImp0 l else l in
      -- latexPrint PREFIX !
      latexPrListApp si con hargs

-- latexPrListConsSpaceR latexPrints spaces around right-associative constructors. 
latexPrListConsSpaceR ::  (Term -> String) ->
                     (Term -> String) ->
                     [Term] -> String
latexPrListConsSpaceR prin sep l =
   let lastl = last l
       latexPrintSubtermsR [x] = prin x
       latexPrintSubtermsR (x:xs) = 
            prin x ++ sep lastl ++ latexPrintSubtermsR xs in
   latexPrintSubtermsR l

-- latexPrListApp latexPrints a list of applications.
latexPrListApp :: SyntaxInfo -> Context -> [Term] -> String
latexPrListApp si con (t:ts) = 
             latexPrintBasic2 si con t ++ latexPrListAppTail si con ts
             
-- latexPrListAppTail prints a list of arguments.
latexPrListAppTail :: SyntaxInfo -> Context -> [Term] -> String
latexPrListAppTail si con [] = ""
latexPrListAppTail si con (t:ts) = 
              "\\at" ++ latexPrintBasic2 si con t ++
              latexPrListAppTail si con ts
             


    

-- Extension: Records:   
latexPrintBasic2 si con r | isRecSelect r =           
                      let (_,t,l) = deconstructRecSelect r in
                      latexPrintBasic2 si con t ++ "\\sel" ++ 
                      latexPrintLabel l
latexPrintBasic2 si con t = latexPrintBasic si con t
-- End Extension: Records:

-- BASIC
latexPrintBasic si con srt | isSort srt = let (_,s) = deconstructSort srt in
                                 latexPrintSort si s
latexPrintBasic si con vr | isVar vr = let (_,v) = deconstructVar vr in
                              latexPrintVar si con v    
latexPrintBasic si con hole | isHole hole = 
                                   let (_,hnum) = deconstructHole hole in
                                   latexPrintHnumSt si hnum
-- Extension: Records:
latexPrintBasic si con r | isRecValue r =       
    let (_,fs) = deconstructRecValue r in
    "\\tot " ++ latexPrintFieldList si (latexPrintField si con "\\mt") fs ++
    "\\tct "
latexPrintBasic si con r | isRecType r =       
    let (_,fs) = deconstructRecType r in
    "\\toT " ++ latexPrintFieldList si (latexPrintField si con "\\mT") fs ++
    "\\tcT "
-- End Extension: Records:
latexPrintBasic si con t = 
   -- Terrible hack to prevent too much parentheses.
   -- The 'then' branch corresponds to the case in latexPrintFactor where we
   -- print additional parentheses.
   let l = breakListL deconstructApp t
       h = head l
       (isVar,v) = deconstructVar h
       isOp = isVar && isOper v
       numImp = getImplicit si v
       expArgs = drop numImp (tail l) in
   if isOp && not (length expArgs == 2) then
      latexPrintTerm' si con t
   else
      "(" ++ latexPrintTerm' si con t ++ ")"

-- Extension: Records:
latexPrintFieldList :: SyntaxInfo -> (b -> String) -> [b] -> String
latexPrintFieldList si f ts = latexPrintFieldList' si f ts 0

latexPrintFieldList' si f [] n = ""
latexPrintFieldList' si f [t] n = f t
latexPrintFieldList' si f (t:ts) n = 
                   f t ++ "\\recsep" ++ latexPrintFieldList' si f ts (n+1)
            
latexPrintField :: SyntaxInfo -> Context -> String -> 
              (RecLabel,Term) -> String
latexPrintField si con s (l,t) = 
                latexPrintLabel l ++ s ++ latexPrintTerm si con t

latexPrintLabel :: RecLabel -> String
latexPrintLabel l = "\\reclabel{"++l++"}"
-- End Extension: Records:


latexPrintSort :: SyntaxInfo -> Sort -> String
latexPrintSort si s = (latexPrintSortSt si s)
                  
latexPrintVar :: SyntaxInfo -> Context -> Vari -> String
latexPrintVar si con v = (latexPrintVarSt si con v)
 
latexPrintVarList :: SyntaxInfo -> Context -> [Vari] -> String
latexPrintVarList si con [v] = latexPrintVar si con v
latexPrintVarList si con (v:vs) =  
                            latexPrintVar si con v ++ "," ++
                            latexPrintVarList si con vs



                                             
-----------------------------
-- OTHER PRINTING ROUTINES --
-----------------------------

                              
-- latexPrintContextE latexPrints a context item. The first boolean specifies whether
-- also the sort has to be latexPrinted, the second whether to shorten the
-- definiendum to '..'
latexPrintContextE :: SyntaxInfo -> Context -> (Sort -> Bool) ->
                      ContextE -> String
latexPrintContextE si con _ ce | isGenDecl ce =
            let (_,(v,t,s),constrs,cts) = deconstructGenDecl ce in
            latexPrintVar si con v ++
            (case constrs of
             CNone -> ""
             -- Extension: Subtyping:
             CSub ->  "\\consub" ++
                       latexPrintTerm si con (head cts)
             -- End Extension: Subtyping
            ) ++
            "\\condecl" ++ latexPrintTermS si con v (t,s)
latexPrintContextE si con pDef ce | isDef ce =
    let (_,(v,d,t,s)) = deconstructDef ce in
    if pDef s then
       latexPrintVar si con v ++ "\\condefterm" ++
       latexPrintTerm' si con d ++ "\\condeftype" ++
       latexPrintTermS si con v (t,s)
    else
       latexPrintVar si con v ++ "\\condefab" ++
       latexPrintTermS si con v (t,s)



-- print term and a sort, but only if the corresponding option is turned on
-- and if the sort is a proper sort
latexPrintTermS :: SyntaxInfo -> Context -> Vari -> (Term,Sort) -> String
{- -- Not possible in LaTeX mode to print also sort.
latexPrintTermS stuff@(conc,_,bas,_) si con v (t,u) | extractOptShowSort si && isProperSort u =
      conc [latexPrintTerm si con (mkPathConTyp v) t,
            "\\:\\has\\:", latexPrintSort si {- (mkPathConSort v)-} u] 
-}
latexPrintTermS si con v (t,u) = latexPrintTerm si con t
  

latexPrintContext :: SyntaxInfo -> Context -> (Sort -> Bool) ->
                     [ContextE] -> [String]
latexPrintContext si con pDef c = map (latexPrintContextE si con pDef) 
                                        (reverse c)

latexPrintContextSt si con b c = 
         map (++"\\newcitem") (latexPrintContext si con b c)




sortToName (SORT s) = sortToName' s

sortToName' "" = ""
sortToName' ('*':s) = "St" ++ sortToName' s
sortToName' ('#':s) = "Bx" ++ sortToName' s
sortToName' (c:s) = c: sortToName' s

latexPrintHnumSt = printHnumSt
latexPrintSortSt si s = "\\sort" ++ sortToName s
latexPrintVarSt si con v | isOper v = "(" ++ latexPrintInfixVar si v ++ ")"
latexPrintVarSt si con v | fst (extractLatex si v) || 
                           v `elem` extractBinder si   = "\\ylv" ++ v
latexPrintVarSt si con v = let (ok,(_,s)) = findTypeSort con v in
                           "\\var" ++ sortToName s ++ "{" ++
                           precedeUnderscores v ++ "}"


precedeUnderscores [] = []
precedeUnderscores ('_':s) = '\\' : '_' : precedeUnderscores s
precedeUnderscores (c:s) = c : precedeUnderscores s


latexPrintInfixVar si v = "\\yiv" ++ concat (map f v) 
                          where
                           f '<' = "lt"
                           f '=' = "eq"
                           f '>' = "gt"
                           f '/' = "sl"
                           f '\\'= "bs"
                           f '&' = "am"
                           f '|' = "ba"
                           f '$' = "do"
                           f ';' = "sc"
                           f '+' = "pl"
                           f '~' = "tw"
                           f s = [s]

latexPrintTermSt si con t = latexPrintTerm si con t


