-- File: Tactics
-- Description: This module defines the tactics for the 
--   prove-mode of the proof assistant.

module Tactics(pAppQQ, pAppGQ, hideTac, unhideTac, unhideAllTac,
               allForbiddenVars,
               introVar, intro, introsTac, introsNumTac, 
               letTac, letTypTac, 
               unfoldDef, unfold, unfoldHyp, simplify, convertTac,
               pattern, exact, assumption, 
               cut, firstTac,
               primApplyTac, primApplyMaxTac, applyTac, applyMaxTac,
               checkExConConcl,
               forwardTac, forgetSorts, primForwardTac, forwardUltTac,
               tryHideTac,
               makeProof, checkExtSolutions, combinePrems,  shiftPrem
               ) where

import HaTuple
import General
import Collect
import HaMonSt
import Basic
import Paths
import SyntaxI
import Typing
import Matchin
import FancyTy
import Reduce
import PTSys
import ProvDat
import MainSta
import GenComs
import Tactals
              


-- In the prove-mode an inhabitant (proof-term) for some type is
-- interactively constructed. During this construction process, this
-- proof-term contains HOLES. TACTICS fill holes partially, resulting in
-- zero or more new holes  (that ought to be easier to fill).
-- The type of a hole is called a GOAL.
-- The construction proces starts with the proof-term being a hole, so with
-- one goal. The process is finished when the proof-term no longer contains
-- holes.


-- Tactics will always deliver a complete proofterm, with all annotation.

-- Many tactics have as argument a term with its type and sort.

----------------------------------------------
--    G E N E R A L   F U N C T I O N S     --
----------------------------------------------


-- checkRule s1 s2 delivers an error if there is no rule of the form
-- (s1,s2,s3)
checkRule :: Sort -> Sort -> M ()
checkRule sort1 sort2 =
     fetchSyn >>= \si ->
     if not (fst (rule12 si sort1 sort2)) then
        genErrS ("No rule of form "++printRule12St si sort1 sort2)
     else
        skip

                      
-------------------------------------
--    B A S I C   T A C T I C S    --
-------------------------------------

-- these basic tactics are used by other tactics to construct proof-terms.
-- many of these have some precondition, that is to be enforced by the
-- calling routine.
-- (an extra check could be implemented, but would be inefficient)

-- They are all described by comments in the following form
--
-- <some textual comment>
--
-- |- ? : <goal of certain form>
-- Given <variables, terms or sorts>
-- With: <that comply to some conditions>
-- ? := <proof-term generated by tactic>
-- New goals are
-- <new context 1> |- ?1 : <new goal 1>
--      ..                     ..
--      ..                     ..
-- <new context n> |- ?1 : <new goal n>



-- pGenAbs var  makes an abstraction over variable var
--
-- Suppose the goal is
-- |- ? : @var':T.U
-- Given var
-- With: var does not occur in total context
-- ? := \var:T.?1
-- New goal is
-- var:t |- ?1 : U[var':=var]
pGenAbs :: Vari -> Tactic
pGenAbs var (goal,locCon,gi,totCon) =
    let goal' = bdwhnf totCon goal
        (ok,(var',g1,sort),cts,ts,g2) = deconstructGenAll goal' in
    if not ok then
       internalErr "No @-type"
    else
    let it = ((var,g1,sort),cts,ts) in
    newHnum >>= \gnum ->
    let proof = mkGenAbs it (mkHole gnum)
        newG2 = subst g2 var' (mkVr var)
        newGi = True : gi
        newGoals = [(gnum,(newG2,(mkGenDecl it `addC` locCon),newGi))] in
    return (proof,newGoals)

pAbs = pGenAbs


-- pDelta var  makes a local definition of variable var
--
-- |- ? : let var'=t.U
-- Given var
-- With: var does not occur in total context
-- ? := let var=t.?1
-- New goal is
-- var=t |- ?1 : U[var':=var]
pDelta :: Vari -> Tactic
pDelta var (goal,locCon,gi,_) =
          let (ok,(var',d,t,s),u) = deconstructDelta goal in
          if not ok then
             internalErr "No let-type"
          else
          let it = (var,d,t,s) in
          newHnum >>= \gnum ->
          let proof = mkDelta it (mkHole gnum)
              newG2 = subst u var' (mkVr var)
              newGi = True : gi
              newGoals = [(gnum,(newG2,(mkDef it `addC` locCon),newGi))] in
          return (proof,newGoals)


-- For the application there are three basic tactics

-- pAppQQ (U,s)  makes an application
--
-- |- ? : T
-- Given U,s
-- With: |- U:s
--       |- U->T : s'
-- ? := ?1 ?2
-- New goals are
-- |- ?1 : U->T
-- |- ?2 : U
pAppQQ :: (Term,Sort) -> Tactic 
pAppQQ (u,s) (goal,locCon,gi,_) =
    newHnum >>= \gnum1 ->
    newHnum >>= \gnum2 ->
    let proof = mkHole gnum1 `mkApp` mkHole gnum2
        newG1 = mkArrow (u,s) goal
        newG2 = u
        newGoals = [(gnum1,(newG1,locCon,gi)),
                    (gnum2,(newG2,locCon,gi))] in
    return (proof,newGoals)

-- pAppGQ U u  makes an application of a given term
--
-- |- ? : T
-- Given t,U
-- With: |- t : U->T
-- ? := t ?1
-- New goal is
-- |- ?1 : U
pAppGQ :: Term -> Term -> Tactic 
pAppGQ u t (goal,locCon,gi,_) =
          newHnum >>= \gnum ->
          let proof = t `mkApp` mkHole gnum
              newGoals = [(gnum,(u,locCon,gi))] in
          return (proof,newGoals)


-- pAppQG @x:U.T u  makes an application to a given term
--
-- |- ? : T[x:=u]
-- Given u, @x:U.T (=typ)
-- With: |- u : U
--       |- @x:U.T : s
-- ? := ?1 u  
-- New goal is
-- |- ?1 : @x:U.T
pAppQG :: Term -> Term -> Tactic 
pAppQG typ u (goal,locCon,gi,_) =
          newHnum >>= \gnum ->
          let proof = mkHole gnum `mkApp` u
              newG2 = typ
              newGoals = [(gnum,(newG2,locCon,gi))] in
          return (proof,newGoals)
 

-- pTerm t  gives a direct term for the goal
--
-- |- ? : T
-- Given t
-- With: |- t : T
-- ? := t
-- No new goals
pTerm :: Term -> Tactic
pTerm t _ =
          let proof = t
              newGoals = [] in
          return (proof,newGoals)


-- pConv t  changes the goal to a beta-delta equivalent one
-- |- ? : T'
-- Given T
-- With: (T =bd T')
-- New goal is
-- |- ? : T
pConv :: Term -> Tactic
pConv t (goal,locCon,gi,_) =
          newHnum >>= \gnum ->
          let proof = mkHole gnum  
              newGoals = [(gnum,(t,locCon,gi))] in
          return (proof,newGoals)


-- pConvCon C  changes the context to a beta-delta equivalent one
-- C' |- ? : T
-- Given C
-- With: C =bd C'
-- New goal is
-- C |- ? : T
pConvCon :: LContext -> Tactic
pConvCon locCon (goal,_,gi,_) =
          newHnum >>= \gnum ->
          let proof = mkHole gnum  
              newGoals = [(gnum,(goal,locCon,gi))] in
          return (proof,newGoals)

-- hideTac vs hides the local variables vs
hideTac :: [Vari] -> Tactic
hideTac vs = hideGenTac vs (\new old -> not new && old) "hidden"

-- unhideTac vs unhides the local variables vs
unhideTac :: [Vari] -> Tactic
unhideTac vs = hideGenTac vs (\new old -> new || old) "unhidden"

-- unhideAllTac vs unhides all local variables
unhideAllTac :: Tactic
unhideAllTac = hideGenTac [] (\new old -> True) ""

-- hideGenTac vs mkNewGi s  changes the hiding status of variables
hideGenTac :: [Vari] -> (Bool->Bool->Bool) -> String -> Tactic
hideGenTac vs mkNewGi s (goal,locCon,gi,_) =
          let locConV = fmap fst (locConToList locCon) in
          if not (vs `sublist` locConV) then
             genErrS ("Only local variables can be " ++ s)
          else     
          newHnum >>= \gnum ->
          let proof = mkHole gnum
              mkNewGi' v old = mkNewGi (v `elem` vs) old
              newGi = zipWith mkNewGi' locConV gi
              newGoals = [(gnum,(goal,locCon,newGi))] in
          return (proof,newGoals)


  
----------------------------------------------
--        I N T R O   T A C T I C S         --
----------------------------------------------

-- freshVar checks the variable doesn't occur in the global and local context
-- and is not the name of some task (since a variable with that name can be
-- added to the context at any moment).
freshVar :: Vari -> LContext -> M Bool
freshVar v locCon =  fmap (v `notElemC`) (allForbiddenVars locCon)

-- allForbiddenVars gives all variables in the global context and
-- the names of tasks.
allForbiddenVars :: LContext -> M (ListsAndTree Vari)
allForbiddenVars locCon = fetchCon >>= \globCon ->
                          fetchTasks >>= \(_,tasks) ->
                          return (fmap extractTaskId tasks +++ 
                                  domCon (locCon `addLocG` globCon))
                   
-- intro tactics add variables to the local context


-- introVar  makes the proofterm
--               1. a lambda-abstraction (when the goal is a @-type)
--               2. a local definition   (when the goal is a let-type)
--            the name of the variable is specified.
introVar :: [Vari] -> Tactic
introVar [] gl = idTac gl
introVar (var:vars) (all,locCon,gi,totCon) | isGenAll all=
    freshVar var locCon >>= \ok ->
    if ok then
       (pGenAbs var `then1Tac` introVar vars) (all,locCon,gi,totCon)
    else
       genErrS ("Variable "++var++" is not fresh")
introVar (var:vars) (delta,locCon,gi,totCon) | isDelta delta =
    freshVar var locCon >>= \ok ->
    if ok then
       (pDelta var `then1Tac` introVar vars) (delta,locCon,gi,totCon)
    else
       genErrS ("Variable "++var++" is not fresh")
introVar _ _ = genErrS "Not so many @-types or definitions"

-- intro is the same as introVar, but the computer creates the name of
-- the variable (see findNiceFree).
intro :: Tactic
intro (all,locCon,gi,totCon) | isGenAll all=                        
    allForbiddenVars locCon >>= \forVars ->
    let (_,(v,_,sort),_,_,_) = deconstructGenAll all
        var = findNiceFree sort forVars v in
    pGenAbs var (all,locCon,gi,totCon)
intro (delta,locCon,gi,totCon) | isDelta delta =
    allForbiddenVars locCon >>= \forVars ->
    let (_,(v,_,_,sort),u) = deconstructDelta delta
        var = findNiceFree sort forVars v in
    pDelta var (delta,locCon,gi,totCon)
intro _ = notAllTypeErr

notAllTypeErr :: M a
notAllTypeErr = genErrS "Not an @-type or definition" 
  
-- intros tries intro as often as possible, at least once
-- (so it aborts with error if once is not possible)
introsTac :: Tactic
introsTac = repeatTac intro

-- introsNum n  tries intro n times
introsNumTac :: Int -> Tactic
introsNumTac n gl = handleS (forTac n intro gl)
                    (\er -> notAllTypeErr)
                    return


{-
-- strongIntro is the same as intro, but tries reduction to see if it is
--             a pi-term.
strongIntro :: Tactic
strongIntro (goal,locCon,totCon) =
             let (ok,it,u) = deconstructWhnfAll totCon goal in
             if ok then
                intro ((mkAll it u),locCon)
             else
                intro (goal,locCon)
-}


-- letTac  adds a definition to the local context, this means that the goal
--         is converted to one with a local definition, on which intro is
--         applied.
letTypTac :: Vari -> PseudoTermIT -> PseudoTermIT -> Tactic
letTypTac var term0 typ0 gl@(goal,locCon,_,totCon) =
         fetchSyn >>= \si ->
         handleTypeErr
            (checkDef si totCon term0 typ0) >>= \(term,typ,sort) ->
         let typ' = if forgetIT typ0==dummyTerm then 
                       bnfNC typ 
                    else
                      typ in
         freshVar var locCon >>= \ok ->
         if not ok then
            genErrS "Variable occurs already"
         else
         (pConv (mkDelta (var,term,typ',sort) goal) `then1Tac`
          intro) gl

letTac :: Vari -> PseudoTermIT -> Tactic
letTac var term0 = letTypTac var term0 dummyTermIT

----------------------------------------------
--   C O N V E R S I O N   T A C T I C S    --
----------------------------------------------

-- conversion tactics replace the goal (or the type of a hypothesis) by
-- a beta-delta-convertible one.


-- unfoldDef  replaces occurrences of var in term by defOfVar. select
--            determines which occurrences are replaced (usually used for
--            unfolding).
unfoldDef :: Context -> Term -> Vari -> Term -> (TermPath,Selector) -> 
             M Term
unfoldDef con term var defOfVar select =
            let f t | deconstructSpecVar t var = (True,defOfVar)
                f t = (False,t) in
            changePathNumberedSubterms f select (domCon con) term


-- unfold  unfolds the named occurrences of var in the goal and then
--         simplifies it
unfold :: Vari -> (TermPath,Selector) -> Tactic
unfold var select (goal,locCon,gi,totCon) =
            let (found,def) = findDef totCon var in
            if not found then
                genErrS (var++" is not defined")
            else
            unfoldDef totCon goal var def select >>= \newG0 ->
            let newG = bnfNC newG0 in
            pConv newG (newG,locCon,gi,totCon)


-- unfoldHyp  unfolds the named occurrences of var in hypothesis hyp and
--            then simplifies it
unfoldHyp :: Vari -> Vari -> (TermPath,Selector) -> Tactic
unfoldHyp var hyp select (goal,locCon,gi,totCon) =
          let (found,def) = findDef totCon var
              (foundHyp,defHyp) = findType locCon hyp in
          if not found then
              genErrS (var++" is not defined")
          else if not foundHyp then
              genErrS ("No variable "++hyp++" in local context")
          else
          unfoldDef totCon defHyp var def select >>= \newTypHyp0 ->
          let newTypHyp = bnfNC newTypHyp0
              r ((t,s),cat,ts)  = ((newTypHyp,s),cat,ts)
              (_,locCon') = updateI locCon hyp r in
          pConvCon locCon' (goal,locCon,gi,totCon)


-- simplify  takes the beta normal-form of the goal
simplify :: Tactic
simplify tr@(goal,_,_,_) =
            -- bnfNC doesn't use context
            pConv (bnfNC goal) tr


-- convertTac  changes  the goal to a given beta-delta-convertible variant
convertTac :: (Term,Sort) -> Tactic
convertTac (term,sort) (goal,locCon,gi,totCon) =
            if not (bdEqual totCon term goal) then
               genErrS "Term not convertible to goal"
            else
            pConv term (goal,locCon,gi,totCon)

  
-- pattern  changes the goal to a specific beta-convertible variant:
--          it abstracts over the selected occurrences of term, and
--          then applies this abstraction to this term
pattern :: (TermPath,Selector) -> (Term,Term,Sort) -> Tactic
pattern select (term,typ,sort) (goal,locCon,gi,totCon) =
           if not (isProperSort sort) then
              genErrS "Term has no sort"
           else
           getType totCon goal >>= \(_,sort2) ->
           if not (isProperSort sort2) then
               internalErr "Goal has no sort"
           else
           checkRule sort sort2 >>
           -- find a name that occurs not in the context and not in the
           -- goal (not even local!)
           allForbiddenVars locCon >>= \forVars ->
           let var= findNiceFree sort (occurVar goal +++ forVars) dummyVar in
           makePattern totCon goal term var typ sort select >>= \newG ->
           handleS (getSort totCon newG)
           (\er -> genErrS "Pattern is not typable")
           (\_ ->
           pConv newG (goal,locCon,gi,totCon))

-- replaceTerm t1 t2 t3 replaces in t1 all occurrences of t2 by t3
-- make sure no variables of t3 will be bound by subterms of t1!
replaceTerm :: Context -> Term -> Term -> Term -> (TermPath,Selector) -> 
               M Term
replaceTerm con t1 t2 t3 select =
           let f t = if t==t2 then (True,t3) else (False,t) in
           changePathNumberedSubterms f select (domCon con) t1


-- makePattern  beta-expands t1 so it is applied to t2.
-- it abstracts on the selected occurrences of t2
-- the name of the variable is v, its type is typ, and the sort is s
makePattern :: Context -> Term -> Term -> Vari -> Term -> Sort -> 
               (TermPath,Selector) -> 
                M Term
makePattern con t1 t2 v typ sort select =
       replaceTerm con t1 t2 (mkVr v) select >>= \t1' ->
       return ((mkAbs (v,typ,sort) t1') `mkApp` t2)





--------------------------------------
--   D I R E C T   T A C T I C S    --
--------------------------------------

-- direct tactics solve the goal, without generating new goals


-- exact  solves the goal, given a term that inhabits the goal
exact :: (Term,Term,Sort) -> Tactic
exact (term,typ,_) (goal,locCon,gi,totCon) =
              fetchSyn >>= \si ->
              if subtype si totCon typ goal then
                 pTerm term (goal,locCon,gi,totCon)
              else
                 genErrS "Term has not correct type"


-- assumption  solves the goal if a variable with the correct type is in
--             the local context
assumption :: Tactic
assumption (goal,locCon,gi,totCon) =
              findVarWithType totCon locCon goal "proof" >>= \v ->
              pTerm (mkVr v) (goal,locCon,gi,totCon)
  
-- findVarWithType con1 con2 typ  searches con2 for a declaration of type
--   subtype of typ. Subtype checking (conversion) is done in con1.
findVarWithType :: Context -> LContext -> Term -> String -> M Vari
findVarWithType con1 con2 typ mess =
         fetchSyn >>= \si ->        
         let find' [] = genErrS ("No "++mess++" in context")
             find' ((v,vTyp):l) = if subtype si con1 vTyp typ then
                                     return v
                                  else
                                     find' l in
         find' (indexedToListIL (lConToType con2))

----------------------------------------------
--           C U T   T A C T I C S          --
----------------------------------------------
 
cut :: (Term,Sort) -> Tactic
cut (term,sort) (goal,locCon,gi,totCon) =
     getSort totCon goal >>= \goalSort ->
     checkRule sort goalSort >>
     pAppQQ (term,sort) (goal,locCon,gi,totCon)


-- firstTac is the same as cut, but the order of the subgoals is different
firstTac :: (Term,Sort) -> Tactic
firstTac ts tr =
    cut ts tr >>=
    (\(p,[goal1,goal2]) -> return (p,[goal2,goal1]))
    
----------------------------------------------
--        A P P L Y   T A C T I C           --
----------------------------------------------

-- We first treat primApplyTac, which is a special case of applyTac.                   
-- primApplyTac (term,typ) (goal,locCon,totCon)
--           (Corresponds with 'Apply term')
-- Rough intuition:
--             primApply tries to find some terms that can be applied to
--             term so we get an inhabitant of our goal.
--             It tries first with zero terms applied, then with one,
--             then with 2 etc. until the term is not of an @-type anymore
--             (it unfolds definitions if necessary)
--             For a fixed number of applicable terms, the resulting type
--             is matched with the current goal. All terms that cannot be
--             found by matching become subgoals.
-- Refinement:
--             We only admit subgoals that have no holes in them. We have
--             to check that this situation does not occur.
-- Implementation:
--    Create with combineConcl a list where different elements correspond
--    to different number of arguments (see combineConcl)
--    Take the first element (exCon,subst) in which every free existential
--    variable in exCon is defined by sigma (checkExConConcl).
--    Make a proof term by function makeProof.
--
--    In more primitive terms
--    1) Peel off some @'s (increasing, starting with zero),
--       and put the pair var,type in list exCon.
--       exCon stands for existential context, since the variables in its
--       declarations may be substituted for.
--    2) Match conclusion with current goal, with dom(exCon) as substitutable
--       vars
--    3) Apply found substitution sigma to exCon
--    4) Check that every free existential variable in exCon is defined
--       by sigma
--    5) All types of unfound vars are new subgoals.
--       The proof-term is t applied to the all substituenda resp. holes.
--
-- Example:
--   Suppose 
--     goal = "a=b"
--     totCon = "{Nat:*, S : Nat->Nat, (=) : Nat->Nat->*, 
--                lem:@x,y:Nat. S x = S y -> x=y, 
--                a:Nat, b:Nat}"
--   and we invoke primApplyTac (lem, @x,y:Nat. ...)
--   Then 
--     pairs = [({x:Nat, y:Nat, H : S a = S b}, <x := a, y := b>]
--     checkExConConl .. = skip
--     makeProof results in a proofterm
--        lem a b ?,  where ? : S a = S b
   
primApplyTac :: MatchOptions -> (Term,Term,Sort) -> Tactic
primApplyTac options (term,typ,_) (goal,locCon,gi,totCon) = 
    fetchSyn >>= \si ->
    let pairs = combineConcl options si totCon goal (emptyLCon,typ) in
    doFirstOk (applyExCon term (goal,locCon,gi,totCon)) makeApplyErr pairs
-- primApplyTac tts = applyTac (tts,[])
                                 
-- applyMax (t:T:s) matches only with the conclusion of T
primApplyMaxTac :: MatchOptions -> (Term,Term,Sort) -> Tactic
primApplyMaxTac options (term,typ,_) (goal,locCon,gi,totCon) = 
    fetchSyn >>= \si ->
    let pairs = combineConclMax options si totCon goal (emptyLCon,typ) in
    doFirstOk (applyExCon term (goal,locCon,gi,totCon)) makeApplyErr pairs
-- primApplyMaxTac tts = applyMaxTac (tts,[])


applyExCon :: Term -> (Term,LContext,GoalInfo,Context) -> (LContext,Subst) ->
              M (Term,Goals)
applyExCon term (goal,locCon,gi,totCon) (exCon,sigma) =
           checkExConConcl (exCon,sigma) >>   
           makeProof term (exCon,sigma) (goal,locCon,gi,totCon)

makeApplyErr messs = 
    let addNum ([ES ""],_) = ""
        addNum ([ES mess,_],(exCon,_))= show (length (indexedToListIL exCon))
                                        ++ " arguments: " ++ mess
        messs' = filter (not.null) (fmap addNum messs) in
    genErrS (if null messs' then
                "Matching can't find any substitution"
             else
                commaSpaces messs')

-- checkExConConcl (exCon,sigma)  every free existential variable in exCon
--      is defined by sigma.
--      It issues an error if this is not the case.
checkExConConcl :: (LContext,Subst) -> M ()
checkExConConcl (exCon,sigma) =                              
    let undefs = domDeclLCon exCon \\ domSubst sigma
                 -- undefined existential variables
        fvExCon = fvLCon exCon in
    checkExConGen undefs fvExCon


-- Now we proceed to the more general case.

-- applyTac ((term,typ,_),termtyps)
--      (Corresponds with 'Apply t On t1,t2,..tn')
--  Intuition: (Roughly, a combination of the Forward tactic and the
--              primApply tactic.)
--             So it applies some terms, including t1 .. tn, to t to make
--             an inhabitant of the goal.
--
-- Implementation:
--    Create with combinePrem on typ and termtyps a list of triples 
--    (exCon,pat,sigma), where exCon contains n declarations for the first
--    n @-items of typ, pat is the body of typ, after n @-items have been
--    stripped and sigma has been applied, and sigma is a substitution
--    for some of the variables in exCon.
--    Now we apply combineConcl on all of these triples, which results
--    in a list of pair (exCon',sigma'). Order these pairs in the length
--    of exCon.
--    Take the first element (exCon,subst) in which every free existential
--    variable in exCon is defined by sigma (checkExConConcl).
--    Make a proof term by function makeProof.
--
-- Example:
--   Suppose 
--     goal = "a<c"
--     totCon = "{Nat:*, S : Nat->Nat, (<) : Nat->Nat->*, 
--                lem:@x,y,z:Nat. x < y -> y < z -> x<z, 
--                a:Nat, b:Nat, c:Nat, H:b<c}"
--   and we invoke applyTac (lem, @x,y:Nat. ...) [(H, b<c)]
--   Then
--     trips =
--       [({x,y,z:Nat,H1:b<c},            c<z -> b<z,  <x:=b, y:=c, H1:=H>),
--        ({x,y,z:Nat,H1:x<b, H2: b<c},   x<c,         <y:=b, z:=c, H2:=H>)]
--     pairs =
--       [({x,y,z:Nat,H1:a<b, H2: b<c},   <x:=a, y:=b, z:=c, H2:=H>)]
--       -- the pat in the first element of trips cannot be matched
--       -- succesfully with the goal
--     pairs' = pairs
--     makeProof results in a proofterm
--        lem a b c ? H, where ? : a<b


-- We could give applyTac another parameter which says how many arguments
-- the term must have at least.
applyTac :: MatchOptions -> ExtTermTS -> Tactic
applyTac = applyGenTac combineConcl

applyMaxTac :: MatchOptions -> ExtTermTS -> Tactic
applyMaxTac = applyGenTac combineConclMax

applyGenTac combine options ((term,typ,_),termtyps) (goal,locCon,gi,totCon) =
    fetchSyn >>= \si ->
    let termtyps' = forgetSorts termtyps
        trips = combinePrems options si totCon typ termtyps'
        comb :: (LContext, Term, Subst) -> [(LContext, Subst)]
        comb (exCon,pat,sigma) = 
          fmap (doSnd (sigma++)) 
              (combine options si totCon goal (exCon,pat))
        pairs = concat (fmap comb trips) in
    checkExtSolutions trips >>
    -- Take a solution with the least number of arguments.
    let pairs' = sortOrd ordPair pairs in
    doFirstOk (applyExCon term (goal,locCon,gi,totCon)) makeApplyErr pairs'

ordPair :: (LContext,Subst) -> (LContext,Subst) -> Bool
ordPair (lCon1,_) (lCon2,_) = 
    length (locConToList lCon1) <= length (locConToList lCon2)



------------------
-- combineConcl --
------------------

-- combineConcl is the major building block of the apply tactic.

-- combineConcl si con typ (exCon, pat)
-- Preconditions: * con |- typ : s  for some sort s
--                * con,exCon |- pat : s'  for some sort s'
--                * exCon contains only declarations (no defs)
--   This function generates a list of pairs (exCon',sigma).
--   Every pair (exCon' = x_1 : T_1, .. x_n : T_n ,
--               sigma) satisfies
--   * if con |- p : @exCon. pat and arg_i = sigma(x_i)
--     then con, exCon'\dom(sigma) |- p arg_1 .. arg_n : pat'
--   * dom(sigma) subset of dom(exCon')
--   * exCon' contains only declarations 
-- Clarifications:
--   * @{y_1 : U_1, .. y_n : U_n}. V = @y_1:U_1,..@y_n:U_n. V
--   * {x:T, y:U, z:V} \ {y} = {x:T, z:V}
--
-- Examples:                   
--   combineConcl "a=b" ([],"@x,y:Nat. S x = S y -> x=y") =
--           [({x:Nat, y:Nat, H : S a = S b}, <x := a, y := b>]
--   combineConcl "A->B" ([],"@P,Q:*. P->(Q->P)",[]) =
--           [({P:*, Q:*, H:B}, <P:=B, Q:=A>),
--            ({P:*, Q:*, H:A->B, H1:Q}, <P := "A->B">)]
--   combineConcl "7=7" ([],"@A:*. @a:A. a = a") =
--           [({A:*, a:A}, {A:=Nat, a=7}]                  
--
-- Implementation:
--    Combine the following pairs:
--    1) match pat with type. For every sigma,
--       return a pair (sigma(exCon'),sigma).
--    2) If pat is an All-type, shift its foremost item in exCon and
--       go into recursion.
--
-- The MatchOptions given as argument are used both in the matching routine
-- and in the code of combineConcl itself.
combineConcl :: MatchOptions -> SyntaxInfo -> Context -> Term ->
                (LContext,Term) -> [(LContext, Subst)]
combineConcl options si con typ pair =
       doMatchConcl options si con typ pair ++
       combineConcl' options si con typ pair

combineConcl' options si con typ (exCon,pat) = 
       let exTotCon = exCon `addLoc` con
           pat' = if mayUnfoldPattern options then 
                     bdwhnf exTotCon pat
                  else
                     pat in
       if isGenAll pat' then
          let pat'' = changeVar pat' (domCon exTotCon)
              (_,it,cts,ts,bodyPat) = deconstructGenAll pat''
              exCon' = mkGenDecl (it,cts,ts) `addC` exCon in
          combineConcl options si con typ (exCon',bodyPat)
       else
          []

-- combineConclMax is similar, but matches only the conclusion.
combineConclMax :: MatchOptions -> SyntaxInfo -> Context -> Term ->
                   (LContext,Term) -> [(LContext, Subst)]
combineConclMax options si con typ (exCon,pat) = 
       let exTotCon = exCon `addLoc` con
           pat' = if mayUnfoldPattern options then 
                     bdwhnf exTotCon pat
                  else
                     pat in
       if isGenAll pat' then
          let pat'' = changeVar pat' (domCon exTotCon)
              (_,it,cts,ts,bodyPat) = deconstructGenAll pat''
              exCon' = mkGenDecl (it,cts,ts) `addC` exCon in
          combineConclMax options si con typ (exCon',bodyPat)
       else
          doMatchConcl options si con typ (exCon,pat)



doMatchConcl options si con typ (exCon,pat) =
       let sigmas = doMatch options si con exCon pat typ in
       fmap (adaptConcl exCon) sigmas

adaptConcl :: LContext -> Subst -> 
              (LContext, Subst)
adaptConcl exCon sigma =
    (applyLConSubst sigma exCon, sigma)
         
------------------------------------------------------
-- Routines for both backward and forward reasoning --
------------------------------------------------------

doMatch :: MatchOptions -> SyntaxInfo -> Context -> LContext -> Term -> 
           Term -> [Subst]
doMatch options si con exCon p t =
    match options si (exCon `addLoc` con, domLCon exCon, p, t)


-- checkExConGen undefs vars  checks that no undefs occur in vars
checkExConGen :: [Vari] -> [Vari] -> M ()
checkExConGen undefs vars =
    let undefsInVars = filter (`elem` vars) undefs in
    if null undefsInVars then
       skip
    else
       genErrS ("Matching didn't find " ++
                commas (removeDoubles undefsInVars))


-- makeProof term (exCon,sigma)  constructs the proofterm
--      by applying term to terms obtained by applying sigma to the
--      variables in exCon, and substituting holes for variables for which
--      no substitution is given.
-- Pre: exCon should only have declarations (no defs.)
--
-- Example:
--    makeProof lem [({x:Nat, y:Nat, H : S a = S b}, <x := a, y := b>] =
--        (pAppQQ "S a = S b") `then1Tac` 
--        (pAppQG dummy "b") `then1Tac` 
--        (pAppQG dummy "a") `then1Tac`
--        pTerm lem
--    which results in a proofterm
--        lem a b ?,  where ? : S a = S b
--
makeProof :: Term -> (LContext,Subst) -> Tactic
makeProof t (exCon,sigma) = makeProof' t (locConToList exCon, sigma)

makeProof' :: Term -> ([ContextE],Subst) -> Tactic
makeProof' term ([], sigma) = pTerm term
makeProof' term (ce:ces, sigma) | isGenDecl ce =
    let (_,(v,vTyp,s),cts,ts) = deconstructGenDecl ce
        (inDom, defV) = defVar' v sigma in
    if inDom then
       -- not correct to say the hole has type 'dummyTerm'
       -- but since the hole will be filled, it is no problem
       pAppQG dummyTerm defV `then1Tac` makeProof' term (ces,sigma)
    else
       case cts of
       CNone -> pAppQQ (bnfNC vTyp,s) `then1Tac`    -- beta-nf of type
                makeProof' term (ces,sigma)
       otherwise -> \_ ->
                    genErrS "Holes with subtyping constraint not permitted"
makeProof' term (ce:ces, sigma) | isDef ce = 
    \_ -> internalErr "function makeProof gets definition in context"


----------------------------------------------
--            F O R W A R D                 --
----------------------------------------------
 
-- forward gets as argument one typed term (say t) and a list of typed terms,
-- say t1,..tn. This tactic tries to make a well-typed application with t 
-- on the head and t1 .. tn as arguments, but interleaved with other
-- arguments as necessary. These other arguments are either holes or terms
-- found by matching.
-- The type of this application is added as assumption to the local context.
-- So forwardTac implements "forward reasoning"
forwardTac :: MatchOptions -> ExtTermTS -> Tactic
forwardTac options ((term,typ,_),termtyps) (goal,locCon,gi,totCon) =
    fetchSyn >>= \si ->
    let termtyps' = forgetSorts termtyps
        -- generate a list of possible solutions
        trips = combinePrems options si totCon typ termtyps' in 
    -- give error if no solutions
    checkExtSolutions trips >>    
    -- order solutions                 
    let trips' = sortOrd ordTrip trips in 
    -- try solutions with least no. of args first.
    doFirstOk (forwardExCon (term,typ) (goal,locCon,gi,totCon))
              makeForwErr trips'      
 
forwardExCon (term,typ) (goal,locCon,gi,totCon) (exCon,resTyp,sigma) =
     checkExConPrem (exCon,resTyp,sigma) >>
     let resTyp' = bnfNC resTyp in
     getSort (exCon `addLoc` totCon) resTyp' >>= \sort ->
     let noArgs = length (locConToList exCon)
         myIntro = if fst3 (deconstructArrowN typ noArgs) then
                      intro `then1Tac` tryHideTac term
                   else
                      intro in
     (firstTac (resTyp',sort) `thenTac`
      [makeProof term (exCon,sigma), myIntro]) (goal,locCon,gi,totCon)              
makeForwErr messs =
    let addNum ([ES mess,_],(exCon,_,_)) = 
                          show (length (indexedToListIL exCon))
                          ++ " arguments: " ++ mess
        messs' = fmap addNum messs in
    genErrS (commaSpaces messs')

checkExtSolutions :: [(LContext, Term, Subst)] -> M ()
checkExtSolutions [] = genErrS "Couldn't find premises of the right form"
checkExtSolutions _ = skip

forgetSorts :: [(Term,Term,Sort)] -> [(Term,Term)]
forgetSorts = fmap (\(a,b,c) -> (a,b))

ordTrip :: (LContext,Term,Subst) -> (LContext,Term,Subst) -> Bool
ordTrip (lCon1,_,_) (lCon2,_,_) = 
    length (locConToList lCon1) <= length (locConToList lCon2)


primForwardTac :: (Term,Term,Sort) -> Tactic
primForwardTac (term,typ,sort) = 
     -- the following code is equivalent to 'forwardTac (tts,[])'
     firstTac (typ,sort) `thenTac` [exact (term,typ,sort), intro]

-- checkExConPrem (exCon,t,sigma)
--      checks that neither t nor types in exCon contain existential vars
--      that are not defined by sigma.
--      If this is false, it issues an error message
checkExConPrem :: (LContext,Term, Subst) -> M ()
checkExConPrem (exCon,t,sigma) = 
    let undefs = domDeclLCon exCon \\ domSubst sigma
        fvExConT = fvLCon exCon ++ fv t in
    checkExConGen undefs fvExConT
                         


-- forwardUltTac is the same as forwardTac, but it always peels off all
-- pi's, and performs a tactic on the goal with the additional assumption.
forwardUltTac :: MatchOptions -> ExtTermTS -> Tactic -> Tactic
forwardUltTac options ((term,typ,_),termtyps) tac (goal,locCon,gi,totCon) =
    fetchSyn >>= \si ->
    let termtyps' = forgetSorts termtyps
        trips = combinePrems options si totCon typ termtyps' in
    checkExtSolutions trips >>
    let trips' = sortOrd ordTrip trips in
    doFirstOk (forwardUltExCon (term,typ) tac (goal,locCon,gi,totCon)) 
              makeForwErr trips'

forwardUltExCon (term,typ) tac (goal,locCon,gi,totCon) (exCon,resTyp,sigma) =
     let (exCon',resTyp') = shiftPrem totCon (exCon,resTyp) in
     checkExConPrem (exCon',resTyp',sigma) >>
     getSort (exCon' `addLoc` totCon) resTyp' >>= \sort ->
     (firstTac (resTyp',sort) `thenTac`
     let noArgs = length (locConToList exCon)
         myIntro = if fst3 (deconstructArrowN typ noArgs) then
                      intro `then1Tac` tryHideTac term
                   else
                      intro in
      [makeProof term (exCon',sigma), myIntro `thenTac` [tac]])
     (goal,locCon,gi,totCon)
                  
tryHideTac :: Term -> Tactic
tryHideTac t gl@(goal,locCon,gi,totCon) =
    let (ok1, v) = deconstructVar t 
        ok2 = v `elem` (fmap fst (locConToList locCon)) in
    if ok1 && ok2 then
       hideTac [v] gl
    else
       idTac gl

               

------------------
-- combinePrem --
------------------
    
-- combinePrem is the major building block of the forward tactic
-- combinePrems is a straightforward extension of this function

-- combinePrem si con (term,typ) (exCon, pat)
-- Preconditions: * con |- term : typ
--                * con,exCon |- pat : s  for some sort s
--                * exCon contains only declarations (no defs)
-- This function generates a list of triples (exCon',pat',sigma).
-- Every triple (exCon' = {x_1 : T_1, .. x_n : T_n} , pat', sigma) satisfies
--   * if con |- p : @exCon. pat
--     and arg_i = sigma(x_i)
--     then con, exCon'\dom(sigma) |- p arg_1 .. arg_n : pat'
--   * for some i, arg_i = term        
--   * dom(sigma) subset of dom(exCon')
--   * exCon' contains only declarations
-- Clarifications:
--   * @{y_1 : U_1, .. y_n : U_n}. V = @y_1:U_1,..@y_n:U_n. V
--   * {x:T, y:U, z:V} \ {y} = {x:T, z:V}
--    
--
-- Examples:
-- combinePrem t (S a = S b) ({}, (@m,n:Nat. S m = S n -> m=n)) = 
--     [({m:Nat, n:Nat, H: S a = S b},  a=b,         <m:=a, n:=b, H:=t>)]
--
-- combinePrem t (a<b)       ({}, (@x,y,z:Nat. x<y -> y<z -> x<z))  =
--     [({x,y,z:Nat,H:a<b},             b<z -> a<z,  <x:=a, y:=b, H:=t>),
--      ({x,y,z:Nat,H:z<a, H1: a<b},    x<b,         <y:=a, z:=b, H1:=t>)]
--
--
-- Inefficient implementation:
--    If pat is an All-type, say (@v:t. body), let exCon' = exCon,v:t and
--    Combine the following triples:
--    1) match v with term in con,exCon'. For every sigma, return a triple
--       (sigma(exCon'), sigma(body), sigma)
--    2) Go into recursion with (exCon', body)
--                             
-- This is inefficient, because the matching routine has to calculate the
-- type of term, which we already know (viz. typ).
-- Since v is always an existential variable in exCon', we know we just
-- have to match v's type with typ, and add the <v:=term> to the resulting
-- substitutions.
-- We use this optimalization only for ordinary All-types, not for bounded
-- All-types, because of simplicity.
--
-- The MatchOptions given as argument are used both in the matching routine
-- and in the code of combinePrem itself.
combinePrem :: MatchOptions -> SyntaxInfo -> Context -> (Term,Term) -> 
               (LContext,Term) -> 
               [(LContext,Term,Subst)]
combinePrem options si con (term,typ) (exCon,pat) =
    let exTotCon = exCon `addLoc` con
        pat' = if mayUnfoldPattern options then
                  bdwhnf exTotCon pat
               else
                  pat in
    if isAll pat' then
       -- optimalization for ordinary All-types
       let pat'' = changeVar pat' (domCon (exCon `addLoc` con))
           (_,it@(v,t,s),body) = deconstructAll pat''
           sigmas = doMatch options si con exCon t typ
           exCon' = mkDecl it `addC` exCon in
       fmap (adaptPrem (exCon', body) . ((v,term) :)) sigmas ++
       combinePrem options si con (term,typ) (exCon', body)
    else
    if isGenAll pat' then
       -- general case for every kind of All-types
       let pat'' = changeVar pat' (domCon (exCon `addLoc` con))
           (_,it@(v,t,s),cts,ts,body) = deconstructGenAll pat''
           exCon' = mkGenDecl (it,cts,ts) `addC` exCon
           sigmas = doMatch options si con exCon' (mkVr v) term in
       fmap (adaptPrem (exCon', body)) sigmas ++
       combinePrem options si con (term,typ) (exCon', body)
    else
       []
 
adaptPrem :: (LContext,Term) -> Subst -> 
             (LContext,Term, Subst)
adaptPrem (exCon,typ) sigma =
    (applyLConSubst sigma exCon, 
     applySubst sigma typ, 
     sigma)
    
-- combinePrems' si con [(term_1,typ_1), .. (term_k,typ_k)] (exCon, pat)
-- Preconditions: * con |- term_i : typ_i
--                * con,exCon |- pat : s  for some sort s
--                * exCon contains only declarations (no defs)
-- This function generates a list of triples (exCon',pat',sigma).
-- Every triple (exCon' = {x_1 : T_1, .. x_n : T_n} , pat', sigma) satisfies
--   * if con |- p : @exCon. pat
--     and arg_i = sigma(x_i)
--     then con, exCon'\dom(sigma) |- p arg_1 .. arg_n : pat'
--   * for all i in 1.. k, there is a j such that arg_j) = term_i
--   * dom(sigma) subset of dom(exCon')
--   * exCon' contains only declarations
--    
--
-- Examples:
-- combinePrems' [(t1,a<b), (t2,b<c)] ({}, (@x,y,z:Nat. x<y -> y<z -> x<z)) =
--     [({x,y,z:Nat,H:a<b, H1: b<c}, 
--         <x:=a, y:=b, z:=c, H:=t1, H1:=t2>)]      
combinePrems' :: MatchOptions -> SyntaxInfo -> Context -> [(Term,Term)] -> 
                 (LContext, Term) -> 
                 [(LContext, Term, Subst)]
combinePrems' options si con [] (lCon,pat) = 
    [(lCon,pat,emptySubst)]
combinePrems' options si con ((termtyp):ttlist) trip =
    let trips = combinePrem options si con termtyp trip 
        comb :: (LContext, Term, Subst) -> [(LContext, Term, Subst)]
        comb (exCon,pat,sigma) = 
          fmap (doThd3 (sigma++)) 
              (combinePrems' options si con ttlist (exCon,pat)) in
    concat (fmap comb trips)


combinePrems :: MatchOptions -> SyntaxInfo -> Context -> Term -> 
                [(Term,Term)] -> [(LContext, Term, Subst)]
combinePrems options si con typ termtyps = 
          combinePrems' options si con termtyps (emptyLCon, typ)


                       
-- shiftPrem (con,pat)  shifts all pis from pat into the con
--                      (it is used in many special tactics).
shiftPrem :: Context -> (LContext,Term) -> (LContext,Term)
shiftPrem con (exCon,pat) | isGenAll pat =
    let pat' = changeVar pat (domCon (exCon `addLoc` con))
        (_,it@(v,t,s),cts,ts,body) = deconstructGenAll pat'
        exCon' = mkGenDecl (it,cts,ts) `addC` exCon in
    shiftPrem con (exCon',body)
shiftPrem _ trip = trip
